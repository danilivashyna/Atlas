# v0.5: Router++, ANN, Path-Aware Routing, & Reticulum RAG

**Atlas v0.5** introduces significant performance improvements and semantic knowledge graph capabilities:

- **ANN Indexing**: Fast kNN search via FAISS (or inproc fallback)
- **Path-Aware Routing**: Inherited weights through the hierarchy with exponential decay
- **Batch Routing**: Process multiple queries efficiently
- **Reticulum**: Content-node associations for semantic retrieval-augmented generation (mini-RAG)
- **Mensum v0 Metrics**: Comprehensive monitoring of router, reticulum, and ANN operations

---

## 1. Architecture Overview

### 1.1 Scoring Formula (v0.5+)

The hierarchical routing now incorporates four components:

$$\text{score}(n) = \alpha \cdot \text{cosine\_norm} + \beta \cdot \text{weight} + \gamma \cdot \text{child\_bonus} + \delta \cdot \text{prior\_path}$$

Where:

- **$\alpha \approx 0.7$** (cosine): Text-node semantic similarity $\in [0, 1]$
- **$\beta \approx 0.15$** (node weight): Node's inherent importance
- **$\gamma \approx 0.1$** (child bonus): Boost if children rank higher
- **$\delta \approx 0.05$** (path prior): Inherited ancestor weights with decay

### 1.2 Path-Aware Prior Computation

Ancestors contribute to node scoring with exponential decay:

$$\text{prior\_path} = \sum_{d=1}^{D} \text{weight}(\text{parent}^d) \cdot \text{decay}^d$$

Where:
- $\text{decay} \approx 0.85$: Exponential attenuation per level
- $D$: Distance from node to ancestor (max ~10 levels)

**Example**: Node `dim2/dim2.4/dim2.4.2` with:
- Parent `dim2/dim2.4` (weight 0.6, $d=1$): contributes $0.6 \times 0.85^1 = 0.51$
- Grandparent `dim2` (weight 0.7, $d=2$): contributes $0.7 \times 0.85^2 = 0.505$
- Total: $\text{prior\_path} = 0.51 + 0.505 + ... \leq 1.0$

---

## 2. ANN Indexing

### 2.1 Backends

#### **Inprocess (default, no external deps)**

```
InprocessANN:
  - Stores node vectors as numpy (n, 5) array
  - Query via inner product + argsort
  - ~O(n) per query, suitable for <100k nodes
  - Serialization: numpy `.npy` file
```

#### **FAISS (optional, fast kNN)**

```
FAISSANNIndex:
  - IndexFlatIP: Inner product search
  - ~O(log n) with GPU acceleration available
  - Requires: pip install faiss-cpu OR faiss-gpu
  - Serialization: FAISS binary + paths JSON
```

#### **Off (disabled)**

```
backend = "off":
  - Returns None; router falls back to full scan
  - Useful for testing or minimal deployments
```

### 2.2 Index Lifecycle

```
1. Build from nodes:  ann.build(nodes)
2. Query:              ann.query(vec5, top_k=k)
3. Persist:            ann.save(path)
4. Reload:             ann.load(path)
```

---

## 3. API Endpoints (v0.5)

### 3.1 POST `/router/route_batch`

**Batch routing with optional ANN + index rebuild.**

```bash
curl -sS http://localhost:8010/router/route_batch \
  -H 'Content-Type: application/json' \
  -d '{
    "items": [
      {"text": "Cats and kittens", "top_k": 5},
      {"text": "Neural networks", "top_k": 3}
    ],
    "use_ann": true,
    "rebuild_index": false
  }' | jq .
```

**Response**:

```json
{
  "results": [
    {
      "items": [
        {"path": "dim2/dim2.4", "score": 0.83, "label": "cats", "meta": null},
        {"path": "dim2", "score": 0.76, "label": "animals", "meta": null}
      ]
    },
    {
      "items": [
        {"path": "dim1/dim1.2", "score": 0.92, "label": "neural networks"}
      ]
    }
  ],
  "trace_id": "abc123de"
}
```

**Parameters**:
- `items[]`: Array of (text, top_k) pairs
- `use_ann`: Use ANN for candidate pre-selection (if index exists)
- `rebuild_index`: Rebuild ANN before routing

---

### 3.2 POST `/router/index/rebuild`

**Rebuild ANN index from current nodes.**

```bash
curl -sS http://localhost:8010/router/index/rebuild \
  -H 'Content-Type: application/json' \
  -d '{"backend": "faiss"}'
```

**Response**:

```json
{
  "ok": true,
  "count": 1234,
  "backend": "faiss",
  "trace_id": "xyz789ab"
}
```

**Notes**:
- Saves index to `$ATLAS_ANN_INDEX_PATH` (default: `/tmp/atlas_nodes.faiss`)
- Idempotent: safe to call multiple times
- Returns count of indexed nodes

---

### 3.3 POST `/reticulum/link`

**Associate content with a node.**

```bash
curl -sS http://localhost:8010/reticulum/link \
  -H 'Content-Type: application/json' \
  -d '{
    "path": "dim2/dim2.4",
    "content_id": "doc:wikipedia/cats",
    "kind": "doc",
    "score": 0.92,
    "meta": {
      "title": "Cats 101: Complete Guide",
      "url": "https://example.com/cats",
      "tags": ["felidae", "domestic"]
    }
  }'
```

**Response**:

```json
{
  "ok": true,
  "trace_id": "link_abc"
}
```

**Parameters**:
- `path`: Node path (e.g., `"dim2/dim2.4"`)
- `content_id`: External reference (URI, doc ID, hash)
- `kind`: Type: `"doc"` | `"snippet"` | `"url"` | custom
- `score`: Relevance $\in [0, 1]$ (used for ranking)
- `meta`: Arbitrary metadata (JSON)

---

### 3.4 POST `/reticulum/query`

**Retrieve linked content by node path (supports subtree).**

```bash
# Query single node
curl -sS http://localhost:8010/reticulum/query \
  -H 'Content-Type: application/json' \
  -d '{"path": "dim2/dim2.4", "top_k": 5}'

# Subtree query (get all links under dim2 and children)
curl -sS http://localhost:8010/reticulum/query \
  -H 'Content-Type: application/json' \
  -d '{"path": "dim2", "top_k": 20}'
```

**Response**:

```json
{
  "items": [
    {
      "content_id": "doc:wikipedia/cats",
      "kind": "doc",
      "score": 0.92,
      "meta": {
        "title": "Cats 101: Complete Guide",
        "url": "https://example.com/cats"
      }
    },
    {
      "content_id": "doc:arXiv/cat-behavior",
      "kind": "doc",
      "score": 0.87,
      "meta": {"title": "Feline Behavior Analysis"}
    }
  ],
  "trace_id": "reticulum_xyz"
}
```

**Parameters**:
- `path`: Node path or prefix for subtree (e.g., `"dim2"` → matches `"dim2*"`)
- `top_k`: Number of results (default: 10, max: 100)

---

## 4. Environment Configuration

### 4.1 Router Parameters

```bash
# Scoring weights (default sum ≈ 1.0)
export ATLAS_ROUTER_ALPHA=0.7      # Cosine similarity weight
export ATLAS_ROUTER_BETA=0.15      # Node weight prior
export ATLAS_ROUTER_GAMMA=0.1      # Child bonus
export ATLAS_ROUTER_DELTA=0.05     # Path-aware prior (v0.5)
export ATLAS_ROUTER_TAU=0.5        # Softmax temperature

# Path-aware decay (v0.5)
export ATLAS_ROUTER_DECAY=0.85     # Exponential decay per level
```

### 4.2 ANN Configuration

```bash
# ANN backend selection
export ATLAS_ANN_BACKEND=inproc    # inproc | faiss | off
export ATLAS_ANN_INDEX_PATH=/tmp/atlas_nodes.faiss
```

### 4.3 Memory Backend

```bash
export ATLAS_MEMORY_BACKEND=sqlite # sqlite | inproc
```

---

## 5. Performance Characteristics

### 5.1 Latency Improvements (ANN vs Full Scan)

For 10k nodes:

| Operation       | Full Scan | ANN (Inproc) | ANN (FAISS) |
|-----------------|-----------|--------------|-------------|
| Single route    | ~50ms     | ~45ms        | ~2ms        |
| Batch (10x)     | ~500ms    | ~100ms       | ~15ms       |
| Index build     | N/A       | ~200ms       | ~300ms      |

**Note**: Exact timings depend on hardware and node count.

### 5.2 Path-Aware Prior Impact

When query similarity is ambiguous (tied nodes), the inherited prior can swing ranking:

```
Query: "animals"
Node A: dim2                (cosine=0.7, weight=0.7, parent=None, prior=0.0)
Node B: dim2/dim2.4         (cosine=0.7, weight=0.5, parent=dim2, prior≈0.51)

Without prior: A and B score ~0.63 (same)
With δ=0.05:   A: 0.63, B: 0.63 + 0.05×0.51 ≈ 0.635 → B ranks slightly higher
```

---

## 6. Data Model: Reticulum Links

### 6.1 Schema

```sql
CREATE TABLE links (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    node_path TEXT NOT NULL,       -- FK to nodes.path
    content_id TEXT NOT NULL,      -- External reference
    kind TEXT DEFAULT 'doc',       -- 'doc' | 'snippet' | 'url' | ...
    score REAL DEFAULT 0.0,        -- [0, 1] relevance
    meta TEXT,                     -- JSON metadata
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_links_node ON links(node_path);
CREATE INDEX idx_links_content ON links(content_id);
```

### 6.2 Operations

```python
from atlas.memory import get_node_store

ns = get_node_store()

# Write link
ns.write_link(
    node_path="dim2/dim2.4",
    content_id="doc:wiki/cats",
    kind="doc",
    score=0.92,
    meta={"title": "Cats", "url": "..."}
)

# Query links for a node
links = ns.get_links("dim2/dim2.4")

# Subtree query
links = ns.query_links(path_prefix="dim2", top_k=20)

# Delete link
ns.delete_link(link_id=123)

# Statistics
stats = ns.stats_links()
# {"count_links": 456, "count_unique_content": 234}
```

---

## 7. Mensum v0 Metrics

### 7.1 Tracked Metrics

```json
{
  "router": {
    "requests_total": 1234,
    "batch_requests_total": 42,
    "avg_latency_ms": {"route": 15.3, "batch": 45.2},
    "ann_backend": "faiss",
    "ann_hit_rate": 0.95,
    "softmax_entropy": 1.28
  },
  "reticulum": {
    "links_total": 5678,
    "avg_query_latency_ms": 3.5
  },
  "nodes": {
    "index_size": 3456,
    "count": 3456
  }
}
```

### 7.2 Accessing Metrics

```bash
curl http://localhost:8010/metrics | jq '.v0_5_mensum'
```

---

## 8. Usage Workflow

### 8.1 Setup & Index Build

```bash
#!/bin/bash
export ATLAS_MEMORY_BACKEND=sqlite
export ATLAS_ANN_BACKEND=faiss
export ATLAS_ROUTER_DECAY=0.85

# Start server
python -m uvicorn src.atlas.api.app:app --port 8010 &
sleep 2

# Populate nodes (from your app)
python << 'PYEOF'
from atlas.memory import get_node_store
ns = get_node_store()
# ... write nodes ...
PYEOF

# Build index
curl -X POST http://localhost:8010/router/index/rebuild \
  -H 'Content-Type: application/json' \
  -d '{"backend": "faiss"}'
```

### 8.2 Link Content to Nodes

```python
from atlas.memory import get_node_store

ns = get_node_store()

# Link Wikipedia articles to semantic nodes
ns.write_link(
    node_path="dim1/dim1.0",
    content_id="wiki:anthropology",
    kind="doc",
    score=0.88,
    meta={"title": "Anthropology", "domain": "social_science"}
)

ns.write_link(
    node_path="dim2/dim2.4",
    content_id="wiki:feline_behavior",
    kind="doc",
    score=0.92,
    meta={"title": "Feline Behavior"}
)
```

### 8.3 Batch Query with Retrieval

```python
import requests

# Route multiple queries
response = requests.post(
    "http://localhost:8010/router/route_batch",
    json={
        "items": [
            {"text": "What are cats?", "top_k": 3},
            {"text": "How does machine learning work?", "top_k": 3}
        ],
        "use_ann": True
    }
)

results = response.json()

# For each result, retrieve linked content
for i, result in enumerate(results["results"]):
    for node in result["items"]:
        path = node["path"]
        # Query reticulum
        content_response = requests.post(
            "http://localhost:8010/reticulum/query",
            json={"path": path, "top_k": 5}
        )
        content = content_response.json()["items"]
        print(f"Query {i}, Node {path}: {len(content)} linked docs")
```

---

## 9. Backward Compatibility

- v0.4 `/router/route` and `/router/activate` unchanged
- Path-aware prior is additive (δ default ≈ 0.05, can be 0)
- Existing deployments work without recompilation
- New features opt-in via environment flags

---

## 10. Roadmap (Post-v0.5)

- **v0.5.1**: Incremental ANN updates (add/delete without rebuild)
- **v0.5.2**: Query embedding cache with TTL
- **v0.5.3**: Reticulum enhancements (reverse edges, versioning, recency weights)
- **v0.6**: Multi-index hierarchical routing (sharding for 100M+ nodes)

---

## 11. Troubleshooting

### ANN Index Not Accelerating

```bash
# Check backend
curl http://localhost:8010/metrics | jq '.v0_5_mensum.router.ann_backend'

# Force rebuild
curl -X POST http://localhost:8010/router/index/rebuild \
  -d '{"backend": "inproc"}'
```

### FAISS Not Installed

```bash
pip install faiss-cpu  # or faiss-gpu
```

### Reticulum Links Not Returning

```bash
# Check if links table exists and has data
python << 'PYEOF'
from atlas.memory import get_node_store
ns = get_node_store()
print(ns.stats_links())
PYEOF
```

---

## References

- [ANN Indexing Review](https://arxiv.org/abs/2001.08812)
- [FAISS Documentation](https://github.com/facebookresearch/faiss)
- [Softmax Temperature Scaling](https://arxiv.org/abs/1706.04223)
